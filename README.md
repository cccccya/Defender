# Defender
华中科技大学网络空间安全学院2020级软件安全课设
## 课程设计要求
实现对MessageBox、heapcreate、heapfree、heapalloc、heapdestroy、createfile、readfile、writefile、RegCreateKeyEx、RegSetValueEx、RegDeleteValue、RegCloseKey、RegOpenKeyEx、socket、bind、send、connect、recv等Win API的截获，并打印出相关参数信息

并检查是否存在重复多次释放堆空间、多文件夹操作、文件自我复制、修改可执行文件、读取文件内容发送到网络、新增注册表项、新增自启动项、修改注册表等异常行为，并对这些行为进行警告提醒。

## 系统总体框架设计
![image](https://user-images.githubusercontent.com/77919385/223654485-6ae37d07-4f31-42f3-b50c-b21719e5e4ec.png)
### Monitor行为监测模块设计
在行为监测模块，我实现了GUI界面，为实现GUI界面的实时刷新，考虑使用多线程，主线程GUI界面负责刷新界面，次线程事务处理线程负责创建并调用注射器进程，从GUI界面获取被监测程序的路径，传输给注射器进程，注射器进程再调用被监测程序并注入DLL。

次线程还需要进行进程间通信，读取共享内存的内容，分析程序调用的API并判断是否存在异常行为。

当接收到数据需要显示的时候，利用Qt的信号与槽机制，发送信号，主线程可以调用槽函数，对需要显示的信息进行显示。

### 进程间通信（共享内存）模块设计
共享内存是进程间通信最简单的方式之一，并且因为是直接对内存进行访问，所以是通信速度最快的方法，当一个进程向共享内存中写入了数据，共享这个区域的所有进程立即就能看到其中的内容。

但是共享内存存在一个缺点，即共享内存本身没有提供一个同步机制，即可能存在多个进程同时对共享内存区域进行读写，这样就会造成错误。应用共享内存的难点就在于实现一个正确的同步机制。

为实现同步，我考虑在共享内存上实现一个简单的消息队列。在我的程序中，因为只存在一读一写，不存在多写的情况，那么我们就可以模拟构建一个消息队列，将消息依次放入队列当中。在写入的过程中就可以在进程自己的内存空间记录上次写入的位置，之后接续往后写即可。

读取的时候也同理，可以在本地自己的内存空间记录上次读取的位置，在每个数据的开头存放一个标志位，表示后面的空间是否有数据写入，那么直接尝试访问标志位的值就可以确定是否有后续数据出现。这样可以方便的实现数据的同步。

因为使用了队列，我们也很容易将普通的队列优化成为循环队列，这样不需要新开过大的内存空间就可以实现大量的数据传输。

为方便后续对信息进行分析，我构建了一个消息结构体，方便在读取消息过后快速获得需要的参数等信息。

### DLL模块设计
DLL模块主要参考任务书中给出的代码，对于其他需要Hook的Win API，在VS2022中写出API名称后可右键进入库中查看相应参数信息，直接将其复制过来即可。

为配合共享内存使用消息结构体，需要将各项参数按照类型转换成char*字符串类型，存入结构体对应字符串当中。同时为了保证数据的正确性，也需要配合使用一些转UTF-8以及宽字节转换的函数达到正确的传输效果。

### 注射器进程模块设计
注射器进程同样参考任务书中的代码，但是为了保证程序的可移植性，需要在选择文件路径的时候将绝对路径改成相对路径。

同时为了能够自主选择监测的程序，考虑通过编译时参数传递将被监测程序的路径传输给注射器。

### MD5模块设计
为监测程序的自我复制操作，我在打开文件时对二进制文件做摘要，然后在程序调用writefile时对写入内容同样做MD5摘要，用map判断摘要是否存在即可。

这样处理出来对空间的节省很大，属于是用时间换空间的操作。同样还能利用MD5的地方还有判断进程是否将读取到的内容发送到网络，同样是对内容做摘要然后用map保存，在send的是否判断即可。



**注意，编译代码时需要提前下载Detours库源码并进行编译，并在编译器上配置该库**
